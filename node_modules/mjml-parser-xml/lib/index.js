"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = MJMLParser;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _htmlparser = _interopRequireDefault(require("htmlparser2"));

var _isObject = _interopRequireDefault(require("lodash/isObject"));

var _findLastIndex = _interopRequireDefault(require("lodash/findLastIndex"));

var _find = _interopRequireDefault(require("lodash/find"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _filter = _interopRequireDefault(require("lodash/fp/filter"));

var _map = _interopRequireDefault(require("lodash/fp/map"));

var _flow = _interopRequireDefault(require("lodash/fp/flow"));

var _cleanNode = _interopRequireDefault(require("./helpers/cleanNode"));

var _convertBooleansOnAttrs = _interopRequireDefault(require("./helpers/convertBooleansOnAttrs"));

var _setEmptyAttributes = _interopRequireDefault(require("./helpers/setEmptyAttributes"));

var indexesForNewLine = function indexesForNewLine(xml) {
  var regex = /\n/gi;
  var indexes = [0];

  while (regex.exec(xml)) {
    indexes.push(regex.lastIndex);
  }

  return indexes;
};

var isSelfClosing = function isSelfClosing(indexes, parser) {
  return indexes.startIndex === parser.startIndex && indexes.endIndex === parser.endIndex;
};

function MJMLParser(xml) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var includedIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var _options$addEmptyAttr = options.addEmptyAttributes,
      addEmptyAttributes = _options$addEmptyAttr === void 0 ? true : _options$addEmptyAttr,
      _options$components = options.components,
      components = _options$components === void 0 ? {} : _options$components,
      _options$convertBoole = options.convertBooleans,
      convertBooleans = _options$convertBoole === void 0 ? true : _options$convertBoole,
      _options$keepComments = options.keepComments,
      keepComments = _options$keepComments === void 0 ? true : _options$keepComments,
      _options$filePath = options.filePath,
      filePath = _options$filePath === void 0 ? '.' : _options$filePath,
      _options$actualPath = options.actualPath,
      actualPath = _options$actualPath === void 0 ? '.' : _options$actualPath,
      _options$ignoreInclud = options.ignoreIncludes,
      ignoreIncludes = _options$ignoreInclud === void 0 ? false : _options$ignoreInclud,
      _options$preprocessor = options.preprocessors,
      preprocessors = _options$preprocessor === void 0 ? [] : _options$preprocessor;
  var endingTags = (0, _flow["default"])((0, _filter["default"])(function (component) {
    return component.endingTag;
  }), (0, _map["default"])(function (component) {
    return component.getTagName();
  }))((0, _objectSpread2["default"])({}, components));
  var cwd = process.cwd();

  if (filePath) {
    try {
      var isDir = _fs["default"].lstatSync(filePath).isDirectory();

      cwd = isDir ? filePath : _path["default"].dirname(filePath);
    } catch (e) {
      throw new Error('Specified filePath does not exist');
    }
  }

  var mjml = null;
  var cur = null;
  var inInclude = !!includedIn.length;
  var inEndingTag = 0;
  var currentEndingTagIndexes = {
    startIndex: 0,
    endIndex: 0
  };

  var findTag = function findTag(tagName, tree) {
    return (0, _find["default"])(tree.children, {
      tagName: tagName
    });
  };

  var lineIndexes = indexesForNewLine(xml);

  var handleInclude = function handleInclude(file, line) {
    var partialPath = _path["default"].resolve(cwd, file);

    var curBeforeInclude = cur;
    if ((0, _find["default"])(cur.includedIn, {
      file: partialPath
    })) throw new Error("Circular inclusion detected on file : ".concat(partialPath));
    var content;

    try {
      content = _fs["default"].readFileSync(partialPath, 'utf8');
    } catch (e) {
      var newNode = {
        line: line,
        file: file,
        absoluteFilePath: _path["default"].resolve(cwd, actualPath),
        parent: cur,
        tagName: 'mj-raw',
        content: "<!-- mj-include fails to read file : ".concat(file, " at ").concat(partialPath, " -->"),
        children: [],
        errors: [{
          type: 'include',
          params: {
            file: file,
            partialPath: partialPath
          }
        }]
      };
      cur.children.push(newNode);
      return;
    }

    content = content.indexOf('<mjml>') === -1 ? "<mjml><mj-body>".concat(content, "</mj-body></mjml>") : content;
    var partialMjml = MJMLParser(content, (0, _objectSpread2["default"])({}, options, {
      filePath: partialPath,
      actualPath: partialPath
    }), [].concat((0, _toConsumableArray2["default"])(cur.includedIn), [{
      file: cur.absoluteFilePath,
      line: line
    }]));

    var bindToTree = function bindToTree(children) {
      var tree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cur;
      return children.map(function (c) {
        return (0, _objectSpread2["default"])({}, c, {
          parent: tree
        });
      });
    };

    if (partialMjml.tagName !== 'mjml') {
      return;
    }

    var body = findTag('mj-body', partialMjml);
    var head = findTag('mj-head', partialMjml);

    if (body) {
      var boundChildren = bindToTree(body.children);
      cur.children = [].concat((0, _toConsumableArray2["default"])(cur.children), (0, _toConsumableArray2["default"])(boundChildren));
    }

    if (head) {
      var curHead = findTag('mj-head', mjml);

      if (!curHead) {
        mjml.children.push({
          file: actualPath,
          absoluteFilePath: _path["default"].resolve(cwd, actualPath),
          parent: mjml,
          tagName: 'mj-head',
          children: [],
          includedIn: []
        });
        curHead = findTag('mj-head', mjml);
      }

      var _boundChildren = bindToTree(head.children, curHead);

      curHead.children = [].concat((0, _toConsumableArray2["default"])(curHead.children), (0, _toConsumableArray2["default"])(_boundChildren));
    } // must restore cur to the cur before include started


    cur = curBeforeInclude;
  };

  var parser = new _htmlparser["default"].Parser({
    onopentag: function onopentag(name, attrs) {
      var isAnEndingTag = endingTags.indexOf(name) !== -1;

      if (inEndingTag > 0) {
        if (isAnEndingTag) inEndingTag += 1;
        return;
      }

      if (isAnEndingTag) {
        inEndingTag += 1;

        if (inEndingTag === 1) {
          // we're entering endingTag
          currentEndingTagIndexes.startIndex = parser.startIndex;
          currentEndingTagIndexes.endIndex = parser.endIndex;
        }
      }

      var line = (0, _findLastIndex["default"])(lineIndexes, function (i) {
        return i <= parser.startIndex;
      }) + 1;

      if (name === 'mj-include') {
        if (ignoreIncludes) return;
        inInclude = true;
        handleInclude(decodeURIComponent(attrs.path), line);
        return;
      }

      if (convertBooleans) {
        // "true" and "false" will be converted to bools
        attrs = (0, _convertBooleansOnAttrs["default"])(attrs);
      }

      var newNode = {
        file: actualPath,
        absoluteFilePath: _path["default"].resolve(cwd, actualPath),
        line: line,
        includedIn: includedIn,
        parent: cur,
        tagName: name,
        attributes: attrs,
        children: []
      };

      if (cur) {
        cur.children.push(newNode);
      } else {
        mjml = newNode;
      }

      cur = newNode;
    },
    onclosetag: function onclosetag(name) {
      if (endingTags.indexOf(name) !== -1) {
        inEndingTag -= 1;

        if (!inEndingTag) {
          // we're getting out of endingTag
          // if self-closing tag we don't get the content
          if (!isSelfClosing(currentEndingTagIndexes, parser)) {
            var partialVal = xml.substring(currentEndingTagIndexes.endIndex + 1, parser.endIndex).trim();
            var val = partialVal.substring(0, partialVal.lastIndexOf("</".concat(name)));
            if (val) cur.content = val.trim();
          }
        }
      }

      if (inEndingTag > 0) return;

      if (inInclude) {
        inInclude = false;
      } // for includes, setting cur is handled in handleInclude because when there is
      // only mj-head in include it doesn't create any elements, so setting back to parent is wrong


      if (name !== 'mj-include') cur = cur && cur.parent || null;
    },
    ontext: function ontext(text) {
      if (inEndingTag > 0) return;

      if (text && text.trim() && cur) {
        cur.content = "".concat(cur && cur.content || '').concat(text.trim()).trim();
      }
    },
    oncomment: function oncomment(data) {
      if (inEndingTag > 0) return;

      if (cur && keepComments) {
        cur.children.push({
          line: (0, _findLastIndex["default"])(lineIndexes, function (i) {
            return i <= parser.startIndex;
          }) + 1,
          tagName: 'mj-raw',
          content: "<!-- ".concat(data.trim(), " -->"),
          includedIn: includedIn
        });
      }
    }
  }, {
    recognizeCDATA: true,
    decodeEntities: false,
    recognizeSelfClosing: true,
    lowerCaseAttributeNames: false
  }); // Apply preprocessors to raw xml

  xml = (0, _flow["default"])(preprocessors)(xml);
  parser.write(xml);
  parser.end();

  if (!(0, _isObject["default"])(mjml)) {
    throw new Error('Parsing failed. Check your mjml.');
  }

  (0, _cleanNode["default"])(mjml); // Assign "attributes" property if not set

  if (addEmptyAttributes) {
    (0, _setEmptyAttributes["default"])(mjml);
  }

  return mjml;
}

module.exports = exports.default;